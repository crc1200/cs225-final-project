# Written Report
**Conor Cunningham, Patrick Cunningham, Danny Metzger, Rachel Samojedny**
## Output and Correctness of Each Algorithm
**BFS:**
For BFS, we first check to make sure the airports are in the file. We then initialize a queue and map to keep track of visited airports. We mark the source airport as visited and push it to the queue. We also keep track of the depths and previous to help create the path at the end.  Entering the "while" loop of the traversal, we traverse until the queue is empty. We pop the front element of the queue and push all unvisited neighbors to the queue and set their previous value and depth value accordingly. We also have a bool check to ensure that there is a path from airport 1 to airport 2 i.e. in the same connected component. We last then go back through the path backwards and then reverse the vector to return a vector that gives the shortest path in terms of least amount of stops i.e. returns those stops. 

The tests we used to ensure our BFS traversal was correct was creating a smaller scale of the test file and finding the expected and ensuring our code matched the expected. We also tested to make sure that you could not travel between two unconnected airports.

**Dijkstra's:**
For Dijkstra's algorithm, we keep track of the distances at each node, whether each node is visited, and each previous node using maps. We first initialize the distances for every airport to be INFINITY, but 0 at the source.  We then use the standard library priority queue where it compares a double, string pair which contains the distance as the double and the airport as the string, this way, it is ordered by distance ascending. This will be "unvisited". We push our source with a distance of 0 to this queue. We then traverse until this queue is empty and pop the top element, which will  always be the airport with the smallest distance. This first checks to make sure it is not visited. If not, we set it to visited and go through each neighbor of this node and calculate the cost using a cost function we created. This cost function uses latitude and longitude that we set for each airport using a coordinate system. If the cost + current distance < distances[neighbor], then we set the new distances[neighbor] to be cost + current distance and set the previous as well as push it to the queue. Once we leave the traversal, we do a similar backtracking through the previous map to print out the path and then return a pair of a vector containing the shoortest path and thethe shortest distance in km from the source to destination airport. 

In order to test this algorith path in t, we created a sample dataset with a set of flights and airports with coordinates in order to calculate ourselves the shortest distance path between airports on our map. We intentionally made the shortest distance path different and with more stops than the path of least stops between two airports. We also tested to make sure that you could not find a path between two airports that are not connected or do not have a flight path in the correct direction as requested.


**Iterative Deepening:**
Iterative deepening depth-first search is an iteration of DFS that adds a depth limit with each search to mimic the traversal bath of BFS. This means that the search traverses level by level rather than the adjacent nodes of each node. This means that IDDFS combines the space efficiency of DFS and the speed of BFS. The basic idea with IDDFS is you start at the root with a depth level of one. You then DFS as you would normally, but are limited to only going 1 node "down". With each iteration, the depth limit is increased until the target node is reached. For our IDDFS code, we first start by checking to make sure that both the target node and the source node are contained within the list of seen airports. Then we simply run a for loop with a max value of the passed-in value, with each iteration calling our DLS function. With each iteration, the depth limit is increased by one. In DLS we run basically the same algorithm as DFS, except we also need to check at the start of the function that the depth limit has not been reached. If it has and the current node is not the target, then we must return false. Else we simply iterate through the neighbors of the source node and recursively call DLS with a depth limit - 1.

## The Answer to our Question
Our ultimate guiding question was to find the optimal way to reach a location, or as we described it, the most "frictionless" path. Since we were not provided the length of the flights, we instead computed this in a few ways using different algorithms. We started answering this question by finding the least amount of stops to get to a destination. We found this by using a BFS traversal through a graph which lets us know the easiest path. We wanted to further our exploration by utilizing the distance between the airports as a factor, as that could change the shortest path. We found this by Dijkstra's algorithm taking into account the distances, therefore we can find the shortest distance and path based on distance. This would often correlate with duration of the flight, as the further the plane has to fly, the longer it has to take. Therefore, we have answered the question. Iterative deepening is an alternative to our BFS approach as it gives more information about the connections between flights, but we all discovered and have decided that Dijkstra's algorithm best answered our question. Along the way, we also discovered we wanted to switch from graph visualization to iterative deepening to further the shortest path discovery as that was our guiding question.


